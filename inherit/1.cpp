#include "Parent.h"
int main()
{
	Child1 cd1;
	Child2 cd2;
	Child3 cd3;

	int n = 0;

	cd1.pub = n; // cd1公有继承子类的对象，可访问并修改父类的公有成员
//	cd1.ptd = n; // ptd为父类保护成员，可以被公有继承的类的对象cd1访问，但是不能修改
                 //	可是这还是错的std::cout << cd1.ptd;
	             // 就是说在这个源文件里不行,因为这不是在子类Child1中,下面则是OK的
                 //	std::cout << cd1.Getptd() << std::endl; // 证明可访问,这就是传说中的利用
	             // 源文件中访问子类对象cd1，子类对象访问自己的成员函数，成员函数访问父类成员。
	
//	n = cd1.ptd; // ！！！！！这还是我的头一次的查觉不知道是对是错：是不是ptd作为父类的
	             // 成员，可以在public继承的子类中，可以被其子类对象访问，但是不能修改，
	             // 像这样在外部文件中是不能够访问的，也就是说ptd作为父类中的protectd对象，
	             // 对于子类相当于public对是源文件等引用它的外部文件相当于private，可是子类中
	             // 到底可不可以修改呢，我试一下子。
	             cd1.Getptd2(); // 这个实验证明，子类可以修改父类protected成员，也就是说宝典中
	                            // p136页可能是错误，因为我的实验结果是：在源文件中不可以访问
				                // 父类保护成员，而在类中又可以访问又可以修改，并不是宝典中说
                                // 可以访问不可以修改。    

    
	n = cd1.Getptd(); // ok!对象访问自己函数，自己的函数在类里面访问父类保护成员。


//	cd2.pub = n;      // Child2是protected继承的类，基类的public成员现在对于外部源文件来说，
	                  // 已经不是public的了，所以在这个源文件中是不能够访问的。
	n = cd2.Getptd(); // ok!对象访问自己函数，自己的函数在类里面访问父类保护成员。
	                  // 此时，出现的情况是这样的，可以跟上面public继承的情况比较，得知
	                  // 在外部源文件中，如果子类对象直接访问从父类继承下来的数据成员，那么
	                  // 公有继承的对象和私有继承的对象是有区别的，可是如果从对象自己调用
	                  // 自己的函数来访问父类这种情况就一样了。
	                  // 结论,depands on 我们在那里访问父类的保护成员，
	                  // 好乱啊，不过我几乎明白了。

//	cd3.pub = n;
	n = cd3.Getptd();

	return 0;
}

